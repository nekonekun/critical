# Настройка

Этот скрипт настраивается только через конфигурационные YAML-файлы.

Хочется просто скопировать и исправить под свои нужды? В самом конце есть [пример](#Пример). 

## Основы

 - Разделы настройки могут располагаться в любом порядке
 - Senders и Formatter разделы обязательны
 - Разделы Static filters, Dynamic filters и Name sections опциональны


## Разделы

### 1. Отправители
 - Ключ: `senders`
 - Можно настроить несколько отправителей, так что раздел `senders` -- список
 - В параметрах каждого отправителя должно быть поле `class`
 - Пока что реализовано два отправителя
 - #### TelegramSender
 - Два параметра: `token` и `receivers`
 - `token`: Telegram Bot API токен
 - `receivers`: список ID чатов (chat_id)
 - Если бот не сможет отправить сообщение получателю (из-за настроек приватности или чего-то в этом духе) -- сообщение будет пропущено, но в следующий раз бот всё равно попробует отправить
 - #### MailSender
 - Восемь параметров: `hostname`, `port`, `username`, `password`, `use_tls`, `sender`, `subject` и `receivers`
 - `hostname`: имя SMTP сервера 
 - `port`: порт SMTP сервера 
 - `username`: имя пользователя SMTP 
 - `password`: пароль SMTP 
 - `use_tls`: необязательно, по умолчанию True. Установи False чтобы отключить TLS 
 - `sender`: имя отправитель
 - `subject`: Тема по умолчанию. Будет использоваться, если в сообщении не будет заголовка "Subject: "
 - `receivers`: список e-mails адресов

### 2. Форматер
 - Ключ: `formatter`
 - У каждого обработчика (в каждом файле настройки) может быть только один форматер
 - В параметрах каждого форматера должно быть поле `class`
 - Пока что реализовано два форматера
 - #### CopyFieldFormatter
 - Один параметр: `field`
 - `field`: одно из полей GELF (Graylog Extended Log Format)
 - #### SimpleMailFormatter
 - Три параметра: `subject_field`, `body_field` и `format`
 - `subject_field`: одно из полей GELF, которое будет скопировано в поле "Subject: "
 - `body_field`: одно из полей GELF, которое будет скопировано в текст письма
 - `format`: шаблон сообщения, по умолчанию `Subject: {subject}\n\n{body}`
### 3. Статические фильтры
 - Ключ: `static_filters`
 - Можно настроить несколько статических фильтров, так что раздел `static_filters` -- список
 - Статические фильтры применяются все одновременно (т.е. как будто условия объединены условием "И")
 - Порядок не имеет значения
 - Хорошей идеей будет иметь как можно меньше разрешающих фильтров и пачку запрещающих 
 - Статические фильтры применяются в первую очередь
 - Статические фильтры имеют доступ ко всем полям GELF
 - В параметрах каждого статического фильтра должно быть поле `class`
 - Пока что реализовано три статических фильтра
 - #### IPSourceFilter
 - Три параметра: `prefixes`, `ips` и `exclude`
 - `prefixes`: список IPv4 подсетей 
 - `ips`: список IPv4 IP-адресом
 - `exclude`: логическое значение, по умолчанию False. Выставь True, чтобы исключить сообщения от подсети/IP-адреса 
 - #### MessageBodyFilter
 - Два параметра: `pattern` и `exclude`
 - `pattern`: подстрока которая будет искаться в поле `full_message`
 - `exclude`: логическое значение, по умолчанию False. Выставь True, чтобы исключить сообщения содержащие подстроку
 - ####MessageBodyAnyFilter
 - То же самое, что и предыдущий фильтр, но с несколькими подстроками
 - Сообщение будет разрешено/отклонено если хотя бы одна из подстрок есть в поле `full_message`
 - Два параметра: `patterns` и `exclude`
 - `patterns`: список подстрок
 - `exclude`: логическое значение, по умолчанию False. Выставь True, чтобы исключить сообщения содержащие любую из подстрок

### 4. Динамические фильтры
 - Ключ: `dynamic_filters`
 - Можно настроить несколько динамических фильтров, так что раздел `dynamic_filters` -- список
 - Динамические фильтры по умолчанию "исключающие"
 - Динамические фильтры применяются в последнюю очередь
 - Решения динамических фильтров зависят от получателя (например `tg_123456789` или `mail_nekonekun@gmail.com`)
 - Динамические фильтры имеют доступ только к тексту отправляемого сообщения (после форматера)
 - В параметрах каждого динамического фильтра должно быть поле `class`
 - Пока что реализован только один динамический фильтр 
 - #### RedisExcludePattern
 - Три параметра: `host`, `port` и `db`
 - `host`: хост Redis 
 - `port`: порт Redis (необязательно). По умолчанию 6379
 - `db`: номер базы данных Redis (необязательно). По умолчанию 0
 - Структура базы Redis выглядит как  ```key: set_of_patterns```, где key описан в предыдущем разделе

### 5. Имя
 - Ключ: `name`
 - Просто имя обработчика, видно только в логах
# Пример
 В этом примере обработчик будет:
 - Ловить сообщения от всех девайсов из подсети 10.0.0.0/8, кроме раздражающих 10.0.0.188 и 10.120.16.240
 - Отбрасывать сообщения, если в них есть неважные подстроки, например `IGMPSNOOPING-6-NO_IGMP_QUERIER`, `SPANTREE-6-INTERFACE` и так далее  
 - Брать поле `short_message` из сообщения GELF
 - Проверять наличие в этом поле подстрок из базы Redis (обработчик будет получать список подстрок по ключам tg_150897551 и tg_-1001234567890)
 - Если не найдёт подстроки из Redis'а, то отправит сообщение @nekone и в наш Чат оповещений
```yaml
name: EVERYTHING

senders:
  - class: TelegramSender
    token: 1234567890:AAAAAbbbbbCddEEff0GhhIIII0J-K0llllM
    receivers:
      - 150897551  # @nekone
      - -1001234567890  # Чат оповещений

static_filters:
  - class: SourceIPFilter
    prefixes:
      - 10.0.0.0/8
  - class: SourceIPFilter
    ips:
      - 10.0.0.188
      - 10.120.16.240
    exclude: true
  - class: MessageBodyAnyFilter
    patterns:
      - IGMPSNOOPING-6-NO_IGMP_QUERIER
      - GMP-4-IGMP_QUERY_VERSION_CONFIGURED_DISCREPANCY
      - SPANTREE-6-INTERFACE
      - SPANTREE-6-STABLE_CHANGE
      - SECURITY-6-SSH_CLIENT_CONNECTING
      - SECURITY-6-SSH_CLIENT_DISCONNECTED
    exclude: True

dynamic_filters:
  - class: RedisExcludeRegexp
    host: 127.0.0.1
    db: 3

formatter:
  class: CopyFieldFormatter
  field: short_message
```
[<< Назад](README.md)